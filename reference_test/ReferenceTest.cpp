//
// Created by 风落叶 on 2019-07-20.
//

#include "ReferenceTest.h"
#include "iostream"
#include "string.h"

using namespace std;

/**
 * 引用（&）：是变量/对象的别名，对引用的操作与对其所绑定的变量或对象操作完全等价；
 * 注意事项：
 * 1）& 不是求地址运算符，而是起标志作用；
 * 2）引用类型必须和其绑定的变量类型相同；
 * 3）声明引用的同时必须对其初始化，否则会报错；
 * 4）引用相当于变量或对象的别名，因此不能再将已有的引用名作为其他变量/对象的名字或别名;
 * 5）引用不是定义一个新的变量或对象，因此内存不会为引用开辟新的空间存储这个引用;
 *
 * 引用的意义：
 * 1.在引用的使用中，单纯给某个变量去别名是毫无意义的，引用的目的主要用于在函数参数的传递中，解决大块数据或对象的传递效率和空间不如意的问题；
 * 2.用引用传递函数的参数，能保证参数在传递的过程中不产生副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性；
 * 3.引用本身是目标变量或对象的别名，对引用的操作本质上就是对目标变量或对象的操作。因此能使用引用时尽量使用引用而非指针；
 */

ReferenceTest::ReferenceTest() {
}


void ReferenceTest::understandReference() {
    //a 是左值，必须在内存中有实体；
    //10 是右值，可以在内存中，也可以在寄存器中；
    //一个对象备用作右值时，使用的是它的内容（值），被当作左值时，使用的是它的内存地址；
    int a = 10;
    //定义引用b，他是变量a的引用，即别名；
    int &b = a;

    cout << "b::" << b << "\n";
    cout << "a的内存地址：：" << &a << ",,b的内存地址：：" << &b << "\n";

    b = 20;
    cout << "a::" << a << ",,b::" << b << "\n";

    //对数组的引用
    int aa[3] = {111, 2, 3};

    //对数组aa的引用；
    int (&bb)[3] = aa;
    cout << aa[0] << "::" << bb[0] << "\n";

    //对指针的引用:类型 *&引用名=指针名;//可以理解为：（类型*） &引用名=指针名，即将指针的类型当成类型*
    int aaa = 20;
    int *pf = &aaa;
    int *&new_pf = pf;

    cout << &pf << "::" << &new_pf << "\n";

}

/**
 * 引用作为函数的参数;
 *
 * 1)当用引用作为函数的参数时，其效果和用指针作为函数参数的效果相当。
 * 当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，
 * 也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。
 *
 * 2)使用引用作为函数的形参时，由于此时形参只是要传递给函数的实参变量或对象的别名而非副本，
 * 故系统不会耗费时间来在内存中开辟空间来存储形参。
 * 因此如果参数传递的数据较大时，建议使用引用作为函数的形参，这样会提高函数的时间效率，并节省内存空间。
 *
 * 3)使用指针作为函数的形参虽然达到的效果和使用引用一样，但当调用函数时仍需要为形参指针变量在内存中分配空间，而引用则不需要这样，
 * 故在C++中推荐使用引用而非指针作为函数的参数.
 *
 * 4)如果在编程过程中既希望通过让引用作为函数的参数来提高函数的编程效率，又希望保护传递的参数使其在函数中不被改变，则此时应当使用对常量的引用作为函数的参数。
 *
 * 5)数组的引用作为函数的参数：C++的数组类型是带有长度信息的，引用传递时如果指明的是数组则必须指定数组的长度
 * @param a
 * @param b
 */
void ReferenceTest::swap(int &a, int &b) {
    int tem = a;
    a = b;
    b = tem;
}

/**
 * 常引用作为参数:只能对其进行访问，不能进行修改；
 * @param a
 */
void ReferenceTest::change(const int &a) {
    cout << "a::" << a << "\n";

    //a = 20;
}


/**
 * 引用作为返回值
 *1.引用作为函数的返回值时，必须在定义函数时在函数名前加&;
 *2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本;
 * @param r
 * @return
 */
float &ReferenceTest::returnFunc(float r) {
    float f = r * r * 3.14F;
    return f;
}

/**
 * 传统的C++引用说的是左值引用；c++11中增加了右值引用；
 * 右值引用关联到右值时，右值被存储到特定位置，右值引用指向该特定位置，也就是说，右值虽然无法获取地址，但是右值引用是可以获取地址的，该地址表示临时对象的存储位置。
 *
 * 右值引用：在代码优化方面会经常用到；
 * 右值引用的基本语法type &&引用名 = 右值表达式；
 * 右值引用不能赋值左值；
 *
 *为什么会引入右值引用？
 * 在旧的C++中，出现了很多不必要的拷贝，因此在某些情况下，对象拷贝完之后，就下来销毁了。
 * 新标准引入了移动操作，减少了很多的复制操作，右值引用正是为了支持移动操作，而引入的新的引用类型；
 */
void ReferenceTest::rightReference() {
    int a = 10;

    //右值引用，只能赋值右值，不能赋值左值；
    int &&b = 10;

    //右值引用不能赋值左值；
    //int &&c = a;

    cout << "a：：" << a << ",,a的内存地址&a：：" << &a << "\n";
    cout << "b：：" << b << ",,b的内存地址&b：：" << &b << "\n";

    //可以将右值引用赋值给左值引用，该左值引用绑定到右值引用指向的对象；
    int &c = b;
    cout << "c：：" << c << ",,c的内存地址&c：：" << &c << "\n";

    //const 左值引用；左值引用无法直接赋值右值，需要加const;
    const int &i = 10;
}

//move函数：可以发现move函数不管传入什么类型参数，不管是左值还是右值，都会返回其右值引用类型;
void ReferenceTest::moveTest() {

    //定义两个字符串变量s1,s2;
    string s1("Hello World"), s2;
    //cout << "字符串s1==" << s1 << "\n";
    s2 = move(string("goog!")); //_Tp 推断为string;
    cout << "s2 == " << s2 << "\n";


    s2 = move(s1); //_Tp 推断为string&；
    cout << "s2 == " << s2 << "\n";

}

/**
 * 右值引用作为函数参数；
 * 左值引用无法直接赋值右值，需要加const
 * @param b
 * @return
 */
int ReferenceTest::swap_change(int &&b) {
    cout << "b::" << b << "\n";
    int c = b + 10;

    ReferenceTest::right_ref = b + 20;
    cout << "right_ref::" << ReferenceTest::right_ref;
    return c;
}




